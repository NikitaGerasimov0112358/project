# Тема 8. Базовые коллекции: словари, кортежи
Отчет по Теме #8 выполнил(а):
- Герасимов Никита Викторович
- ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |



знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### В школе, где вы учились, узнали, что вы крутой программист и попросили написать программу для учителей, которая будет при вводе кабинета писать для него ключ доступа и статус, занят кабинет или нет. 
request = int(input('Введите номер кабинета: '))

dictionary = {

101: {'key': 1234, 'access': True},

102: {'key': 1337, 'access': True},

103: {'key': 8943, 'access': True},

104: {'key': 5555, 'access': False},

None: {'key': None, 'access': False},

}

response = dictionary.get(request)

if not response:

response = dictionary[None]

key = response.get('key')

access = response. get('access')

print(key, access)

### Результат
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/Снимок%20экрана%20(46).png)
## Выводы
Код запрашивает у пользователя номер кабинета и проверяет, есть ли такой кабинет в словаре. Если номер существует, то программа выводит ключ и значение параметра access для этого кабинета.

## Лабораторная работа №2
### Алексей решил создать самый большой словарь в мире. Для этого он придумал функцию dict_maker (**kwargs), которая принимает неограниченное количество параметров «ключ: значение» и обновляет созданный им словарь my_dict, состоящий всего из одного элемента «first» со значением «so easy». Помогите Алексею создать данную функцию.
from pprint import pprint

my_dict = {'first': 'so easy'}

def dict_maker(**kwargs) :

my_dict.update(**kwargs)

dict_maker(a1=1, a2=20, a3=54, a4=13)

dict_maker(name='Михаил', age=31, weight=70, eyes_color='blue')

pprint(my_dict)
### Результат
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/Снимок%20экрана%20(47).png)

## Выводы
Код создаёт словарь с помощью функции dict_maker(), которая принимает произвольное количество именованных аргументов (**kwargs) и добавляет их в существующий словарь my_dict с помощью метода .update().

## Лабораторная работа №3
### Для решения некоторых задач бывает необходимо разложить строку на отдельные символы. Мы знаем что это можно сделать при помощи split(), у которого более гибкая настройка для разделения для этого, но если нам нужно посимвольно разделить строку без всяких условий, то для этого мы можем использовать кортежи (tuple). 
input_string = 'HelloWorld'

result = tuple(input_string)

print(result)

print (list (result))

### Результат
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/Снимок%20экрана%20(48).png)

## Выводы
Код принимает строку 'HelloWorld' и преобразует её в кортеж с помощью функции tuple(), а затем выводит полученный кортеж, после снова печатает преобразованный кортеж, но уже как список с помощью функции list(), которая преобразует кортеж в список.
  
## Лабораторная работа №4
### Вовочка решил написать крутую функцию, которая будет писать имя, возраст и место работы, но при этом на вход этой функции будет поступать кортеж. Помогите Вовочке написать эту программу.
def personal_info(name, age, company='unnamed' ):

print(f"Имя: {name} Возраст: {age} Компания: {company}")

tom = ("Григорий", 22)

personal_info(*tom)

bob = ("Георгий", 41, "Yandex")

personal_info(*bob)

### Результат

![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/Снимок%20экрана%20(49).png)
## Выводы
Функция выводит на экран строку с информацией о человеке, используя переданные аргументы.

## Лабораторная работа №5
### Для сопровождения первых лиц государства X нужен кортеж, но никто не может определиться с порядком машин, поэтому вам нужно написать функцию, которая будет сортировать кортеж, состоящий из целых чисел по возрастанию, и возвращает его. Если хотя бы один элемент не является целым числом, то функция возвращает исходный кортеж.
def tuple_sort(tpl):

for elm in tpl:
    
if not isinstance(elm, int):
        
return tpl
            
return tuple(sorted(tpl))

if __name__ == '__main__':

print (tuple_sort((5, 5, 3, 1, 9)))
    
print(tuple_sort((5, 5, 2.1, '1', 9)))

### Результат
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/Снимок%20экрана%20(50).png)

## Выводы
Сортировка и возвращение кортежа

## Самостоятельная работа №1
### 1) Самостоятельно создайте класс и его объект. Они должны отличаться от тех, что указаны в методичке и лабораторных заданиях.

  class Animal:
      def __init__(self, species, age):
          self.species = species
          self.age = age
  
  dog = Animal("Dog", 5)
  print(f"Species: {dog.species}, Age: {dog.age}")


### Результат.
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/(59).png)
## Выводы
В данной задаче был создан класс Animal с двумя атрибутами: species (вид) и age (возраст). Объект dog был создан на основе этого класса, и его атрибуты были успешно выведены в консоль. Это задание помогает понять основы создания классов и объектов в Python.

## Самостоятельная работа №2
### 2)	Самостоятельно создайте атрибуты и методы для ранее созданного класса.
  class Animal:
      def __init__(self, species, age):
          self.species = species
          self.age = age
    
      def make_sound(self):
          print(f"The {self.species} makes a sound.")

  dog = Animal("Dog", 5)
  dog.make_sound()



### Результат.
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/(60).png)
## Выводы

Здесь класс Animal был дополнен методом make_sound, который выводит сообщение о звуке, издаваемом животным. Это задание показало, как добавлять методы к классу для выполнения определенных действий.

## Самостоятельная работа №3
### 3)	Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом.

  class Animal:
      def __init__(self, species, age):
          self.species = species
          self.age = age
  
      def make_sound(self):
          print(f"The {self.species} makes a sound.")
  
  class Dog(Animal):
      def __init__(self, age, breed):
          super().__init__("Dog", age)
          self.breed = breed
      
      def bark(self):
          print("Woof!")
  
  labrador = Dog(3, "Labrador")
  labrador.make_sound()
  labrador.bark()



### Результат.
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/(61).png)
## Выводы
Здесь был создан подкласс Dog, который наследует класс Animal. В классе Dog добавлен метод bark, который выводит сообщение "Woof!". Это задание показало, как использовать наследование для создания более специфичных классов на основе более общих.

## Самостоятельная работа №4
### 4)	Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом.

  class Animal:
      def __init__(self, species, age):
          self.species = species
          self.__age = age  # Инкапсуляция атрибута age
      
      def get_age(self):
          return self.__age
      
      def set_age(self, age):
          if age >= 0:
              self.__age = age
          else:
              print("Invalid age")
  
  dog = Animal("Dog", 5)
  print(dog.get_age())
  dog.set_age(6)
  print(dog.get_age())
  dog.set_age(-1)  # Неправильный возраст




### Результат.
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/(62).png)

## Выводы

Здесь был реализован механизм инкапсуляции для атрибута age класса Animal, делая его приватным. Метод get_age предоставляет доступ к значению, а метод set_age позволяет изменять его с проверкой. Это задание демонстрирует принцип инкапсуляции, который помогает защитить данные внутри класса.

## Самостоятельная работа №5
### 5) Самостоятельно реализуйте полиморфизм. Он должен отличаться от примеров в методичке.

  class Animal:
      def make_sound(self):
          print("Some generic animal sound")
  
  class Dog(Animal):
      def make_sound(self):
          print("Woof!")
  
  class Cat(Animal):
      def make_sound(self):
          print("Meow!")

  animals = [Dog(), Cat(), Animal()]
  
  for animal in animals:
      animal.make_sound()



### Результат.
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/(63).png)
## Выводы
Здесь был продемонстрирован полиморфизм. Классы Dog и Cat переопределили метод make_sound класса Animal, каждый со своим собственным звуком. Полиморфизм позволяет вызывать один и тот же метод для различных объектов, обеспечивая гибкость и расширяемость кода.

## Общий вывод 
В ходе выполнения этих заданий были изучены основные принципы объектно-ориентированного программирования (ООП): создание классов и объектов, работа с атрибутами и методами, наследование, инкапсуляция и полиморфизм. Эти задания помогли глубже понять концепции ООП, что является важным аспектом структурирования кода и создания более гибких, масштабируемых программ.
