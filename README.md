# Тема 11.  Итераторы и генераторы
Отчет по Теме #9 выполнил(а):
- Герасимов Никита Викторович
- ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | - |
| Задание 4 | + | - |
| Задание 5 | + | - |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию init (), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

```python
class Nikita:
    __slots__ = ['name']

    def __init__(self, name):
        if name == 'Никита':
            self.name = f"Да, я {name}"
        else:
            self.name = f"Я не {name}, а Никита"


person1 = Nikita('Алексей')
person2 = Nikita('Никита')
print(person1.name)
print(person2.name)

person2.surname = 'Герасимов'
```

### Результат
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/7.png)

## Выводы
Создание класса с одним свойством. Создание функции init(). Проверка, что будет если указать несществующий атрибут класса.

## Лабораторная работа №2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в которой будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

```python
class Icecream:
        def __init__(self, ingredient=None):
            if isinstance(ingredient, str):
                self.ingredient = ingredient
            else:
                self.ingredient = None

        def composition(self):
            if self.ingredient:
                print(f"Мороженое с {self.ingredient}")
            else:
                print('Обычное мороженое')


icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```
### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/2t9.png)

## Выводы
Создание класса Icecream с методом, который выводит на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». Программа воспринимает только атрибуты типа string.

## Лабораторная работа №3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.

```python
class MyClass:
        def __init__(self, value):
            self._value = value

        def set_value(self, value):
            self._value = value

        def get_value(self):
            return self._value

        def del_value(self):
            del self._value

        value = property(get_value, set_value, del_value, "Свойство value")

obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())

```

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/3t9.png)

## Выводы
Этот код создает класс MyClass с атрибутом _value и свойством value, которое управляет доступом к этому атрибуту через методы get_value, set_value и del_value. Это свойство позволяет получать, устанавливать и удалять значение _value с помощью property. Ошибка возникает в последней строке print(obj.get_value()), потому что после вызова obj.del_value() атрибут _value был удален. Попытка его чтения приводит к ошибке AttributeError, так как атрибут больше не существует.
  
## Лабораторная работа №4
### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.

```python
class Mammal:
    className = 'Mammal'


class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'

class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'

dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")

```

### Результат

![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/4t9.png)
## Выводы
Этот код создает базовый класс Mammal и два подкласса Dog и Cat, которые наследуют от Mammal. Этот код выводит информацию о каждом из объектов dog и cat, используя их свойства.
## Лабораторная работа №5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.

```python
class Russian:

    @staticmethod
    def greeting():
        print("Привет")

class English:

    @staticmethod
    def greeting():
        print("Hello")

def greet(language):
    language.greeting()

ivan = Russian()
greet(ivan)
john = English()
greet(john)

```

### Результат
![Меню](https://github.com/DanilAlexeevich/DanilKholkin/raw/main/img/5t9.png)

## Выводы
Этот код создает два класса Russian и English, каждый из которых имеет статический метод greeting, выводящий приветствие на соответствующем языке.

## Самостоятельная работа 
### Создание класса.
```python
  # Класс Tomato
class Tomato:
    # Статическое свойство stages, содержащее стадии созревания
    stages = {0: "Отсутствует", 1: "Цветение", 2: "Зеленый", 3: "Красный"}

    def __init__(self, index):
        self._index = index
        self._state = 0  # начальное состояние (отсутствует)

    # Метод grow(), который переводит томат на следующую стадию созревания
    def grow(self):
        if self._state < 3:  # последняя стадия - 3 (Красный)
            self._state += 1

    # Метод is_ripe(), проверяющий, созрел ли томат
    def is_ripe(self):
        return self._state == 3

    # Метод для отображения текущей стадии томата (дополнительно для проверки)
    def get_state(self):
        return Tomato.stages[self._state]

# Класс TomatoBush
class TomatoBush:
    def __init__(self, count):
        # Создаем список объектов Tomato
        self.tomatoes = [Tomato(index) for index in range(count)]

    # Метод grow_all(), который заставляет созревать все томаты на кусте
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()

    # Метод all_are_ripe(), проверяющий, все ли томаты созрели
    def all_are_ripe(self):
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    # Метод give_away_all(), очищающий куст от созревших томатов
    def give_away_all(self):
        self.tomatoes = []

# Класс Gardener
class Gardener:
    def __init__(self, name, plant):
        self.name = name
        self._plant = plant

    # Метод work(), заставляющий садовника ухаживать за растением
    def work(self):
        print(f"{self.name} ухаживает за растением...")
        self._plant.grow_all()

    # Метод harvest(), позволяющий садовнику собрать урожай
    def harvest(self):
        if self._plant.all_are_ripe():
            print(f"{self.name} собирает урожай.")
            self._plant.give_away_all()
        else:
            print("Урожай еще не созрел!")

    # Метод knowledge_base(), выводящий справку
    @staticmethod
    def knowledge_base():
        print("Справка по уходу за растением: Ухаживайте за растением, пока все томаты не созреют.")


```

### Результат.
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/6.png)
## Выводы
Класс Tomato:

Класс представляет собой модель томата с различными стадиями созревания. Благодаря методам grow() и is_ripe(), томат может поэтапно созревать, и его зрелость может быть проверена.
Вывод: Класс Tomato удачно реализует концепцию состояния объекта, позволяя отслеживать и изменять стадию созревания томата.
Класс TomatoBush:

Этот класс моделирует куст с несколькими томатами. Он содержит методы для одновременного роста всех томатов (grow_all()), проверки зрелости всех томатов (all_are_ripe()) и уборки куста (give_away_all()).
Вывод: Класс TomatoBush демонстрирует умение работать с коллекцией объектов, предоставляя методы для коллективных операций.
Класс Gardener:

Этот класс отвечает за уход за растением (кустом томатов). Садовник может ухаживать за растением и собирать урожай, если все томаты созрели. Также реализован статический метод knowledge_base(), дающий справку о процессе выращивания.
Вывод: Класс Gardener эффективно взаимодействует с кустом, показывая пример управления зависимым объектом, и содержит полезную справочную информацию.

## Самостоятельная работа №1
### Тест 1.
```python
 Gardener.knowledge_base()

```

### Результат.
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/1.png)
## Выводы
Выводсправочной информации.

## Самостоятельная работа №2
### Тест 2.
```python
bush = TomatoBush(4)
```
### Результат.
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/2.png)
## Выводы
Создание куста с 4 томатами

## Самостоятельная работа №3
### Тест 3.
```python
gardener = Gardener("Иван", bush)

```

### Результат.
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/3.png)
## Выводы 
Создание садовника.


## Самостоятельная работа №4
### Тест 4.
```python
for _ in range(3):  # трёхкратный уход, чтобы достичь стадии созревания
    gardener.work()
    if gardener._plant.all_are_ripe():
        break
```

### Результат.
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/4.png)
## Выводы
Садовник ухаживает за кустом несколько раз.

## Самостоятельная работа №5
### Тест 5.
```python
gardener.harvest()
```

### Результат.
![Меню](https://github.com/NikitaGerasimov0112358/project/raw/main/scrin/5.png)
## Выводы
Садовник пытается собрать урожай

## Общий вывод 
Все три класса — Tomato, TomatoBush и Gardener — демонстрируют применение основных концепций объектно-ориентированного программирования: инкапсуляции, наследования и полиморфизма. Система моделирует процесс ухода за растением, где каждый объект выполняет свою роль и взаимодействует с другими объектами. Это задание позволяет понять принципы ООП и научиться структурировать код, разделяя ответственность между различными объектами.







